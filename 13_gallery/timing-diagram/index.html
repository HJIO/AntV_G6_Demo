<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>时序图</title>
    <style>
        ::-webkit-scrollbar {
            display: none;
        }

        html,
        body {
            overflow: hidden;
        }
    </style>
</head>

<body>
    <div id="mountNode"></div>
    <script>/*Fixing iframe window.innerHeight 0 issue in Safari*/document.body.clientHeight;</script>
    <script src="https://gw.alipayobjects.com/os/antv/assets/g6/1.2.1/g6.min.js"></script>
    <script src="https://gw.alipayobjects.com/os/antv/assets/lib/jquery-3.2.1.min.js"></script>
    <script type="text/javascript">
        const Util = G6.Util;
        const G = G6.Canvas.G;
        const data = {
            "nodes": [
                {
                    "id": "imbilegw",
                    "active": false
                },
                {
                    "id": "msgbroker",
                    "active": false
                },
                {
                    "id": "tthove",
                    "active": true
                },
                {
                    "id": "aliPlool",
                    "active": false
                }
            ],
            "edges": [
                {
                    "id": "imbilegw-msgbroker",
                    "shape": "line",
                    "source": "imbilegw",
                    "target": "msgbroker",
                    "order": 1
                },
                {
                    "id": "msgbroker-tthove",
                    "shape": "line",
                    "source": "msgbroker",
                    "target": "tthove",
                    "order": 2
                },
                {
                    "id": "tthove-imbilegw",
                    "shape": "line",
                    "source": "tthove",
                    "target": "imbilegw",
                    "order": 3
                },
                {
                    "id": "tthove-msgbroker",
                    "shape": "line",
                    "source": "tthove",
                    "target": "msgbroker",
                    "order": 4
                },
                {
                    "id": "aliPlool-msgbroker",
                    "shape": "line",
                    "source": "aliPlool",
                    "target": "msgbroker",
                    "order": 5
                },
                {
                    "id": "imbilegw-aliPlool",
                    "shape": "line",
                    "source": "imbilegw",
                    "target": "aliPlool",
                    "order": 6
                },
                {
                    "id": "tthove-aliPlool",
                    "shape": "line",
                    "source": "tthove",
                    "target": "aliPlool",
                    "order": 7
                }
            ]
        };

        function findById(items, id) {
            var rst;
            Util.each(items, function (item) {
                if (item.id === id) {
                    rst = item;
                    return false;
                }
            });
            return rst;
        }

        function compareIndex(id1, id2, items) {
            var node1 = findById(items, id1);
            var node2 = findById(items, id2);
            var index1 = items.indexOf(node1);
            var index2 = items.indexOf(node2);
            return index1 > index2;
        }

        G6.registerNode('sequence-node', {
            draw(cfg, group) {
                const model = cfg.model;
                const x = cfg.x;
                const y = cfg.y;
                const color = cfg.color;
                const label = cfg.label;
                const labelStyle = cfg.labelStyle ? cfg.labelStyle : {
                    fontSize: 12,
                    textAlign: 'center',
                    textBaseline: 'middle',
                    fill: '#333'
                };
                const size = cfg.size;
                const width = size[0];
                const height = size[1];
                const barWidth = model.barWidth ? model.barWidth : 10;
                const labelHeight = model.labelHeight ? model.labelHeight : 26; // 标签高度
                const slideMargin = model.slideMargin ? model.slideMargin : 20;
                let keyShape; // 用作锚点连接的关键shape

                // 上标签背景
                group.addShape('rect', {
                    attrs: {
                        x: x - width / 2,
                        y: y - height / 2,
                        width: width,
                        height: labelHeight,
                        stroke: 'black',
                        radius: 5,
                        lineWidth: 1,
                        fill: color
                    }
                });

                // 上标签文字
                group.addShape('text', {
                    attrs: Util.mix({
                        x: x,
                        y: y - height / 2 + labelHeight / 2,
                        text: label
                    }, labelStyle)
                });

                // 下标签背景
                group.addShape('rect', {
                    attrs: {
                        x: x - width / 2,
                        y: y + height / 2 - labelHeight,
                        width: width,
                        height: labelHeight,
                        stroke: 'black',
                        radius: 5,
                        lineWidth: 1,
                        fill: color
                    }
                });

                // 下标签文字
                group.addShape('text', {
                    attrs: Util.mix({
                        x: x,
                        y: y + height / 2 - labelHeight / 2,
                        text: label
                    }, labelStyle)
                });

                // 中间虚线
                group.addShape('line', {
                    attrs: {
                        x1: x,
                        y1: y - height / 2 + labelHeight,
                        x2: x,
                        y2: y + height / 2 - labelHeight,
                        lineDash: [5, 5],
                        lineWidth: 0.5,
                        stroke: '#333'
                    }
                });

                // // 关键图形
                keyShape = group.addShape('rect', {
                    attrs: {
                        x: x - barWidth / 2,
                        y: y - height / 2 + labelHeight + slideMargin,
                        width: barWidth,
                        height: height - 2 * labelHeight - slideMargin * 2
                    }
                });

                return keyShape;
            },
            getAnchorPoints: cfg => {
                const model = cfg.model;
                const anchorNumber = model.anchorNumber;
                const cellRatio = 1 / anchorNumber;
                const rst = [];
                let i;
                for (i = 0; i < anchorNumber; i++) {
                    rst.push([1, cellRatio * i + 1 / 2 * cellRatio]);
                }
                for (i = 0; i < anchorNumber; i++) {
                    rst.push([0, cellRatio * i + 1 / 2 * cellRatio]);
                }
                return rst;
            }
        });

        G6.registerEdge('sequence-edge', {
            draw(cfg, group) {
                const model = cfg.model;
                const color = cfg.color;
                const points = cfg.points;
                const slideWidth = model.slideWidth;
                const slideHeight = model.slideHeight;
                const sourcePoint = points[0];
                const targetPoint = points[points.length - 1];
                const pointsArr = []; // points 数组
                let keyShape; // 关键图形
                let sourceX;
                let targetX;

                Util.each(points, p1 => {
                    pointsArr.push([p1.x, p1.y]);
                });
                sourceX = sourcePoint.x - slideWidth - 1;
                targetX = targetPoint.x;
                if (targetPoint.x < sourcePoint.x) {
                    sourceX = sourcePoint.x;
                    targetX = targetPoint.x - slideWidth;
                }
                keyShape = group.addShape('polyline', {
                    attrs: {
                        points: pointsArr,
                        stroke: 'black',
                        arrow: true
                    }
                });
                group.addShape('rect', {
                    attrs: {
                        x: sourceX,
                        y: sourcePoint.y - slideHeight / 2,
                        width: slideWidth,
                        height: slideHeight,
                        fill: color[0]
                    }
                });
                group.addShape('rect', {
                    attrs: {
                        x: targetX,
                        y: targetPoint.y - slideHeight / 2,
                        width: slideWidth,
                        height: slideHeight,
                        fill: color[1]
                    }
                });
                return keyShape;
            }
        }, 'arrow');

        const net = new G6.Net({
            id: 'mountNode', // 容器ID
            forceFit: true,      // 宽度自适应
            height: window.innerHeight,         // 画布高
            dragable: true,      // 是否支持元素拖动
            resizeable: true,    // 是否支持元素变形
            selectable: true,    // 是否允许选中
            fitView: 'autoZoom', // 自动缩放
            grid: {
                forceAlign: true,  // 是否支持网格对齐
                cell: 10           // 网格大小
            }
        });

        // 映射规则
        net.node().color("active", val => {
            let rst;
            if (val) {
                rst = '#FFC3CE';
            } else {
                rst = '#FFFFD4';
            }
            return rst;
        })
            .label('id');
        net.edge().color("source*target", (val0, val1) => {
            let rst = [];
            if (val0 === 'imbilegw') {
                rst[0] = '#3388B3';
            }
            if (val0 === 'msgbroker') {
                rst[0] = '#FF8467';
            }
            if (val0 === 'tthove') {
                rst[0] = '#00C3F8';
            }
            if (val0 === 'aliPlool') {
                rst[0] = '#7FEF9F';
            }
            if (val1 === 'imbilegw') {
                rst[1] = '#3388B3';
            }
            if (val1 === 'msgbroker') {
                rst[1] = '#FF8467';
            }
            if (val1 === 'tthove') {
                rst[1] = '#00C3F8';
            }
            if (val1 === 'aliPlool') {
                rst[1] = '#7FEF9F';
            }
            return rst;
        });

        // 布局
        const nodes = data.nodes;
        const edges = data.edges;
        const nodeMapper = net.get('nodeMapper');
        const height = net.getHeight();
        const marginLeft = 20;
        const padding = 6;
        const cellHeight = 500;
        const barWidth = 10;
        const labelHeight = 20;
        const barHeight = cellHeight - labelHeight * 2;
        const labelShape = new G.Text(); // 用于测量label宽度
        const slideMargin = 10;
        let maxOrder = 0;
        let currentX = 1;
        let cellWidth;
        let cfg;
        let bbox;

        Util.each(edges, function (edge) {
            if (edge.order > maxOrder) {
                maxOrder = edge.order;
            }
        });

        Util.each(nodes, function (node) {
            cfg = nodeMapper.mapping(node);
            labelShape.attr('text', cfg.label);
            labelShape.attr('x', 0);
            labelShape.attr('y', 0);
            bbox = labelShape.getBBox();
            cellWidth = bbox.maxX - bbox.minX + 2 * padding;
            node.shape = 'sequence-node';
            node.x = currentX + cellWidth / 2;
            node.y = 1 / 2 * height;
            currentX += cellWidth + marginLeft;
            node.size = [];
            node.size[0] = cellWidth;
            node.size[1] = cellHeight;
            node.labelHeight = labelHeight;
            node.barWidth = barWidth;
            node.slideMargin = slideMargin;
            node.anchorNumber = maxOrder;
        });

        Util.each(edges, function (edge) {
            edge.shape = 'sequence-edge';
            edge.slideHeight = (barHeight - slideMargin * 2) / maxOrder;
            edge.slideWidth = barWidth;
            if (compareIndex(edge.source, edge.target, nodes)) {
                edge.sourceAnchor = edge.order + maxOrder - 1;
                edge.targetAnchor = edge.order - 1;
            } else {
                edge.sourceAnchor = edge.order - 1;
                edge.targetAnchor = edge.order + maxOrder - 1;
            }
        });

        labelShape.destroy();

        net.source(nodes, edges); // source 必须在定义映射规则之后
        net.render();
    </script>
</body>

</html>